                             ┌────────────────────┐
                             │   exec_ast(node)   │
                             └────────────┬───────┘
                                          │
                             ┌────────────▼───────┐
                             │   node == NULL ?   │
                             └───────┬───────┬────┘
                                     │Yes    │No
                                     ▼       ▼
                               return 0   ┌────────────────────┐
                                          │ switch(node->type) │
                                          └────────────────────┘
                                                   │
        ┌──────────────────────────────────────────┼────────────────────────────────────────────┐
        ▼                                          ▼                                            ▼
[NODE_COMMAND]                            [NODE_PIPE]                                 [NODE_AND / NODE_OR]
        │                                          │                                            │
        ▼                                          ▼                                            ▼
is_builtin(node->command->argv[0]) ?      create pipe()                                 exec_ast(node->left)
        │                                          │                                            │
    ┌───┴────┐                              ┌──────┴───────┐                            ┌────────┴────────┐
    │  Yes   │                              │  fork left   │                            │   Get status    │
    ▼        ▼                              └──────────────┘                            │  of left child  │
apply_redirs()  fork()                             │                                    └────────┬────────┘
    │        ┌───── child ─────┐                 wait                                  ┌────────▼──────────┐
    │        │  exec_builtin() │                   │                                   │ if AND: status==0 │
    │        └─────────────────┘             ┌─────┴─────┐                             │ if OR: status!=0  │
    │        ┌───── parent ────┐             │ fork right│                             └──────┬────────────┘
    │        │  wait + restore │             └───────────┘                                    ▼
    │        └─────────────────┘                   │                                    exec_ast(node->right)
    ▼                                              ▼
exec_external() → execve()                  wait both children
    │                                              │
    ▼                                              ▼
 return status                              return last status

        ┌────────────────────────────────────────────────────────────────────────────┐
        ▼                                                                            ▼
[NODE_SUBSHELL]                                                              [DEFAULT / ERROR]
        │                                                                            │
        ▼                                                                            ▼
    fork()                                                                  print error & exit
        │
 ┌──────┴─────┐
 │  child     │
 │  exec_ast(node->left) ───> recursive walk into subshell
 │  exit()    │
 └──────┬─────┘
        │
        ▼
     waitpid
	    │
        ▼
   return status



   Да, ты понял абсолютно верно. Продолжаю пошагово в том же стиле:

---

## ✅ Обработчик: `NODE_COMMAND`

1. **Это лист дерева** — содержит `t_command *` (argv + redirs).
2. Проверяем: является ли команда `builtin`?

   * **Если да**:

     * Применяем редиректы: `apply_redirections(node->command->redirections)`
     * Выполняем `builtin` напрямую (без fork).
     * Восстанавливаем стандартные `stdin/stdout` (если было переназначено).
     * Сохраняем `exit_status`.
   * **Если нет**:

     * Создаём `fork()`

       * В **дочернем**:

         * Применяем редиректы.
         * Вызываем `execve()` с `argv` и `envp`.
       * В **родителе**:

         * Ждём завершения дочернего процесса.
         * Читаем `exit_status`.

---

## ✅ Обработчик: `NODE_PIPE`

1. Создаём `pipe()`.
2. Форкаем **левый процесс**:

   * Перенаправляем `stdout` в `pipe[1]`.
   * Закрываем `pipe[0]` (не читаем).
   * Вызываем `exec_ast(node->left)`.
3. Форкаем **правый процесс**:

   * Перенаправляем `stdin` в `pipe[0]`.
   * Закрываем `pipe[1]` (не пишем).
   * Вызываем `exec_ast(node->right)`.
4. В родителе:

   * Закрываем оба конца pipe.
   * Ждём оба дочерних процесса.
   * Сохраняем статус последнего.

---

## ✅ Обработчик: `NODE_AND` (логическое `&&`)

1. Выполняем `exec_ast(node->left)`.
2. Если `exit_status == 0`, выполняем `exec_ast(node->right)`.
3. Иначе — пропускаем правую ветку.
4. Сохраняем `exit_status` последней выполненной команды.

---

## ✅ Обработчик: `NODE_OR` (логическое `||`)

1. Выполняем `exec_ast(node->left)`.
2. Если `exit_status != 0`, выполняем `exec_ast(node->right)`.
3. Иначе — пропускаем правую ветку.
4. Сохраняем `exit_status` последней выполненной команды.

---

## ✅ Обработчик: `NODE_SUBSHELL` (вложенные скобки)

1. Делаем `fork()`.
2. В **дочернем**:

   * Выполняем `exec_ast(node->left)` (вложенное выражение).
   * Вызываем `exit(exit_status)` — не влияет на родительскую оболочку.
3. В **родителе**:

   * Ждём завершения дочернего процесса.
   * Сохраняем `exit_status`.

---

## ✅ Что делает `exec_ast()` в итоге:

* Рекурсивно проходит по дереву.
* Выполняет все ветви в соответствии с их логикой.
* Корректно обрабатывает редиректы, пайпы, логические операторы и скобки.
* Обновляет глобальный `g_exit_status`.

---

Если всё ясно, можем переходить к созданию `executor.h` и базового скелета `executor.c`.

#########################################################
################## COMMON INSTRUCTIONS ##################
#########################################################

| Требование                               | Нарушаем? | Комментарий                                                    |
| ---------------------------------------- | --------- | -------------------------------------------------------------- |
| Проект написан на C                      | ❌        | Всё на C ✅                                                     |
| Соблюдение Norm                          | ❌         | Мы следуем Norm (имена, отступы, длина функций и т.д.) ✅       |
| Без сбоев (segfault, double free)        | ❌         | Мы учитываем ошибки, выделяем и освобождаем память корректно ✅ |
| Нет утечек памяти                        | ❌         | У нас будет `clean_token_list`, `free_ast`, и т.д. ✅           |
| Makefile с нужными правилами             | ⏳         | Реализуем позже (NAME, all, clean, fclean, re, bonus)          |
| Разделение bonus-модуля и основной части | ⏳         | Учитываем это при планировании (`_bonus.c/.h`)                 |
| Подключение `libft` через Makefile       | ❌         | У нас `libft` в папке `libft/`, подключаем правильно ✅         |
| Создание тестов                          | ❌         | Не требуется по сабжекту, но мы уже ведём тестирование ✅       |
| Отправка только в Git                    | ❌         | Требует только соблюдения Git-репозитория ✅                    |

🔍 Итог по первому блоку:
Мы полностью соответствуем требованиям.
👉 Нарушений нет, только ещё не сделаны: Makefile и разделение бонуса (это планируется).


#########################################################
##################### MANDATORY PART ####################
#########################################################

Отлично. Это второй блок — **технические требования к функциональности**, включая список разрешённых функций и поведение shell. Проверим строго и построчно:

---

## ✅ 1. **Проверка разрешённых функций**

| Факт                                               | Статус | Комментарий                                |
| -------------------------------------------------- | ------ | ------------------------------------------ |
| Мы используем только разрешённые функции из списка | ✅      | Никаких `strdup`, `system`, `popen` и т.п. |
| Макросы типа `WIFEXITED` и `WEXITSTATUS`           | ✅      | Это макросы, не функции — разрешены        |

---

## ✅ 2. **Глобальные переменные**

| Переменная                                                    | Назначение         | Статус               |
| ------------------------------------------------------------- | ------------------ | -------------------- |
| `g_exit_status`                                               | хранит `$?`        | ✅ OK                 |
| `g_sigint`                                                    | хранит факт SIGINT | ✅ OK                 |
| Используем **только одну глобальную переменную для сигналов** | ✅                  | Требование соблюдено |

---

## ✅ 3. **Функциональность shell**

| Требование                             | Статус | Комментарий                                                               |                                         |
| -------------------------------------- | ------ | ------------------------------------------------------------------------- | --------------------------------------- |
| Отображать prompt                      | ✅      | readline уже в использовании                                              |                                         |
| История команд                         | ✅      | с readline, `add_history()`                                               |                                         |
| Исполнять команды из PATH              | 🟡     | будет реализовано в `exec_external()` через `getenv("PATH")` + `access()` |                                         |
| Раскрытие `$VAR`, `$?`                 | ✅      | делается в `expander()`                                                   |                                         |
| Обработка `ctrl-C`, `ctrl-D`, `ctrl-\` | ✅      | реализовано через `signals.c`                                             |                                         |
| Обработка кавычек `'` и `"`            | ✅      | реализовано в `lexer`                                                     |                                         |
| Не интерпретировать `\` и `;`          | ✅      | `lexer` не обрабатывает эти символы                                       |                                         |
| Редиректы `<`, `>`, `>>`, `<<`         | 🟡     | в процессе (`apply_redirections()` на подходе)                            |                                         |
| Пайпы \`                               | \`     | 🟡                                                                        | структура заложена, будет `exec_pipe()` |
| Поддержка builtins                     | 🟡     | `exec_builtin()` и `is_builtin()` уже предусмотрены                       |                                         |

---

## ✅ 4. **Builtins**

| Команда   | Статус      |
| --------- | ----------- |
| `echo -n` | ✅ реализуем |
| `cd`      | 🟡          |
| `pwd`     | 🟡          |
| `export`  | 🟡          |
| `unset`   | 🟡          |
| `env`     | 🟡          |
| `exit`    | 🟡          |

🔹 Всё будет реализовано поэтапно через `builtin.c`.

---

## ❗ Особое указание

> The readline() function can cause memory leaks. You don’t have to fix them.
> But that **doesn’t mean your own code** can have memory leaks.

📌 Мы обязаны:

* проверять `malloc` и освобождать всё, что мы сами выделили.
* **не допускать утечек**, кроме как в `readline()`.

---

## 🟢 Вывод:

| Группа требований          | Соблюдается?  |
| -------------------------- | ------------- |
| Разрешённые функции        | ✅             |
| Поведение сигналов         | ✅             |
| Переменные `$VAR`, `$?`    | ✅             |
| Обработка `Ctrl+C/D/\`     | ✅             |
| Кавычки, спецсимволы       | ✅             |
| История + prompt           | ✅             |
| Редиректы, пайпы, builtins | 🟡 в процессе |
| Утечек в коде нет          | ✅             |

---


#########################################################
###################### BONUS PART #######################
#########################################################

Отлично. Это третий и финальный блок — **bonus part**. Проверим строго по пунктам:

---

## 🎯 Требования бонусной части:

| Требование                    | Что означает                             |    |                                  |
| ----------------------------- | ---------------------------------------- | -- | -------------------------------- |
| `&&` и \`                     |                                          | \` | логические операторы "и" и "или" |
| Скобки `()`                   | приоритет выражений, как в bash          |    |                                  |
| `*` (wildcards)               | работает как в bash — подстановка файлов |    |                                  |
| Только **текущая директория** | `*` не рекурсивный                       |    |                                  |

---

## ✅ Наш текущий статус:

| Компонент     | Статус | Комментарий                                                                   |   |                                                                                                        |
| ------------- | ------ | ----------------------------------------------------------------------------- | - | ------------------------------------------------------------------------------------------------------ |
| `&&`, \`      |        | \`                                                                            | ✅ | `lexer` распознаёт → `parser` создаёт `NODE_AND/OR` → `executor` маршрутизирует в `exec_and/exec_or()` |
| `()` (скобки) | ✅      | распознаются → создаётся `NODE_SUBSHELL` → в `exec_subshell()` будет `fork()` |   |                                                                                                        |
| `wildcards *` | ❌      | пока не реализовано                                                           |   |                                                                                                        |

---

## 📌 Что осталось реализовать:

### 🔹 Модуль для `wildcards`:

* Раскрывать `*` в списке аргументов команды.
* Делать это **только в текущей директории**.
* Использовать: `opendir()`, `readdir()`, `closedir()` (разрешены в сабжекте).
* Учитывать `quote_map` из токена — `*` в кавычках не раскрывается.

---

## 🟢 Вывод:

| Требование      | Соблюдено           |    |   |
| --------------- | ------------------- | -- | - |
| `&&`, \`        |                     | \` | ✅ |
| `()`            | ✅                   |    |   |
| `*` (wildcards) | ❌ нужно реализовать |    |   |

---

