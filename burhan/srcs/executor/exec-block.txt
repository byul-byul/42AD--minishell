                             ┌────────────────────┐
                             │   exec_ast(node)   │
                             └────────────┬───────┘
                                          │
                             ┌────────────▼───────┐
                             │   node == NULL ?   │
                             └───────┬───────┬────┘
                                     │Yes    │No
                                     ▼       ▼
                               return 0   ┌────────────────────┐
                                          │ switch(node->type) │
                                          └────────────────────┘
                                                   │
        ┌──────────────────────────────────────────┼────────────────────────────────────────────┐
        ▼                                          ▼                                            ▼
[NODE_COMMAND]                            [NODE_PIPE]                                 [NODE_AND / NODE_OR]
        │                                          │                                            │
        ▼                                          ▼                                            ▼
is_builtin(node->command->argv[0]) ?      create pipe()                                 exec_ast(node->left)
        │                                          │                                            │
    ┌───┴────┐                              ┌──────┴───────┐                            ┌────────┴────────┐
    │  Yes   │                              │  fork left   │                            │   Get status    │
    ▼        ▼                              └──────────────┘                            │  of left child  │
apply_redirs()  fork()                             │                                    └────────┬────────┘
    │        ┌───── child ─────┐                 wait                                  ┌────────▼──────────┐
    │        │  exec_builtin() │                   │                                   │ if AND: status==0 │
    │        └─────────────────┘             ┌─────┴─────┐                             │ if OR: status!=0  │
    │        ┌───── parent ────┐             │ fork right│                             └──────┬────────────┘
    │        │  wait + restore │             └───────────┘                                    ▼
    │        └─────────────────┘                   │                                    exec_ast(node->right)
    ▼                                              ▼
exec_external() → execve()                  wait both children
    │                                              │
    ▼                                              ▼
 return status                              return last status

        ┌────────────────────────────────────────────────────────────────────────────┐
        ▼                                                                            ▼
[NODE_SUBSHELL]                                                              [DEFAULT / ERROR]
        │                                                                            │
        ▼                                                                            ▼
    fork()                                                                  print error & exit
        │
 ┌──────┴─────┐
 │  child     │
 │  exec_ast(node->left) ───> recursive walk into subshell
 │  exit()    │
 └──────┬─────┘
        │
        ▼
     waitpid
	    │
        ▼
   return status



   Да, ты понял абсолютно верно. Продолжаю пошагово в том же стиле:

---

## ✅ Обработчик: `NODE_COMMAND`

1. **Это лист дерева** — содержит `t_command *` (argv + redirs).
2. Проверяем: является ли команда `builtin`?

   * **Если да**:

     * Применяем редиректы: `apply_redirections(node->command->redirections)`
     * Выполняем `builtin` напрямую (без fork).
     * Восстанавливаем стандартные `stdin/stdout` (если было переназначено).
     * Сохраняем `exit_status`.
   * **Если нет**:

     * Создаём `fork()`

       * В **дочернем**:

         * Применяем редиректы.
         * Вызываем `execve()` с `argv` и `envp`.
       * В **родителе**:

         * Ждём завершения дочернего процесса.
         * Читаем `exit_status`.

---

## ✅ Обработчик: `NODE_PIPE`

1. Создаём `pipe()`.
2. Форкаем **левый процесс**:

   * Перенаправляем `stdout` в `pipe[1]`.
   * Закрываем `pipe[0]` (не читаем).
   * Вызываем `exec_ast(node->left)`.
3. Форкаем **правый процесс**:

   * Перенаправляем `stdin` в `pipe[0]`.
   * Закрываем `pipe[1]` (не пишем).
   * Вызываем `exec_ast(node->right)`.
4. В родителе:

   * Закрываем оба конца pipe.
   * Ждём оба дочерних процесса.
   * Сохраняем статус последнего.

---

## ✅ Обработчик: `NODE_AND` (логическое `&&`)

1. Выполняем `exec_ast(node->left)`.
2. Если `exit_status == 0`, выполняем `exec_ast(node->right)`.
3. Иначе — пропускаем правую ветку.
4. Сохраняем `exit_status` последней выполненной команды.

---

## ✅ Обработчик: `NODE_OR` (логическое `||`)

1. Выполняем `exec_ast(node->left)`.
2. Если `exit_status != 0`, выполняем `exec_ast(node->right)`.
3. Иначе — пропускаем правую ветку.
4. Сохраняем `exit_status` последней выполненной команды.

---

## ✅ Обработчик: `NODE_SUBSHELL` (вложенные скобки)

1. Делаем `fork()`.
2. В **дочернем**:

   * Выполняем `exec_ast(node->left)` (вложенное выражение).
   * Вызываем `exit(exit_status)` — не влияет на родительскую оболочку.
3. В **родителе**:

   * Ждём завершения дочернего процесса.
   * Сохраняем `exit_status`.

---

## ✅ Что делает `exec_ast()` в итоге:

* Рекурсивно проходит по дереву.
* Выполняет все ветви в соответствии с их логикой.
* Корректно обрабатывает редиректы, пайпы, логические операторы и скобки.
* Обновляет глобальный `g_exit_status`.

---

Если всё ясно, можем переходить к созданию `executor.h` и базового скелета `executor.c`.
